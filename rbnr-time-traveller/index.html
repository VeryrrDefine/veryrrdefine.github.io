<!DOCTYPE html>
<html lang="zh">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VeryrrDefine的主页</title>
    <link href="../style.css" rel="stylesheet" />

    <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.0.3/pako.min.js"></script>
    <script>
        "use strict";
        var pako_1 = pako;
        function simpleEncrypt(data, key) {
            var keyBytes = new TextEncoder().encode(key);
            return new Uint8Array(data.map(function (byte, index) { return byte ^ keyBytes[index % keyBytes.length]; }));
        }
        function simpleDecrypt(data, key) {
            return simpleEncrypt(data, key);
        }
        const saveSerializer = {
            encoder: new TextEncoder(),
            decoder: new TextDecoder(),
            legacyStartString: "RBNSaveFile",
            newStartString: "RBNRNewSaveFileFormat",
            newStartStringV2: "RBNRNewSaveFileFormatV2", // 新版本标识
            endString: "EndOfSaveFile",
            encryptionKey: "The Encryption Key to encrypt the save!!!bxbxbx",
            // 新版步骤（使用有问题的混淆函数，保持兼容）
            newSteps: [
                {
                    serialize: function (x) { return JSON.stringify(x); },
                    deserialize: function (x) { return JSON.parse(x); },
                },
                {
                    serialize: function (x) { return saveSerializer.encoder.encode(x); },
                    deserialize: function (x) { return saveSerializer.decoder.decode(x); },
                },
                {
                    serialize: function (x) { return (0, pako_1.deflate)(x); },
                    deserialize: function (x) { return (0, pako_1.inflate)(x); },
                },
                // 数据加密
                {
                    serialize: function (x) {
                        return simpleEncrypt(x, saveSerializer.encryptionKey);
                    },
                    deserialize: function (x) {
                        return simpleDecrypt(x, saveSerializer.encryptionKey);
                    },
                },
                // 数据混淆（旧版，有问题的实现，保持兼容）
                {
                    serialize: function (x) {
                        var result = new Uint8Array(x.length);
                        for (var i = 0; i < x.length; i++) {
                            var newPos = (i * 7 + 13) % x.length;
                            result[newPos] = x[i];
                        }
                        return result;
                    },
                    deserialize: function (x) {
                        var result = new Uint8Array(x.length);
                        for (var i = 0; i < x.length; i++) {
                            var originalPos = (i * 7 + 13) % x.length;
                            result[i] = x[originalPos];
                        }
                        return result;
                    },
                },
                {
                    serialize: function (x) {
                        return Array.from(x)
                            .map(function (byte) { return String.fromCharCode(byte); })
                            .join("");
                    },
                    deserialize: function (x) {
                        return Uint8Array.from(Array.from(x).map(function (char) { return char.charCodeAt(0); }));
                    },
                },
                {
                    serialize: function (x) { return btoa(x); },
                    deserialize: function (x) { return atob(x); },
                },
                {
                    serialize: function (x) {
                        return x
                            .replace(/=+$/g, "")
                            .replace(/0/g, "0a")
                            .replace(/\+/g, "0b")
                            .replace(/\//g, "0c");
                    },
                    deserialize: function (x) {
                        return x.replace(/0b/g, "+").replace(/0c/g, "/").replace(/0a/g, "0");
                    },
                },
                {
                    serialize: function (x) {
                        return saveSerializer.newStartString + x + saveSerializer.endString;
                    },
                    deserialize: function (x) {
                        return x.slice(saveSerializer.newStartString.length, -saveSerializer.endString.length);
                    },
                },
            ],
            newStepsV2: [
                {
                    serialize: function (x) { return JSON.stringify(x); },
                    deserialize: function (x) { return JSON.parse(x); },
                },
                {
                    serialize: function (x) { return saveSerializer.encoder.encode(x); },
                    deserialize: function (x) { return saveSerializer.decoder.decode(x); },
                },
                {
                    serialize: function (x) { return (0, pako_1.deflate)(x); },
                    deserialize: function (x) { return (0, pako_1.inflate)(x); },
                },
                // 数据加密
                {
                    serialize: function (x) {
                        return simpleEncrypt(x, saveSerializer.encryptionKey);
                    },
                    deserialize: function (x) {
                        return simpleDecrypt(x, saveSerializer.encryptionKey);
                    },
                },
                // 数据混淆（新版，使用XOR确保可逆）
                {
                    serialize: function (x) {
                        var result = new Uint8Array(x.length);
                        for (var i = 0; i < x.length; i++) {
                            result[i] = x[i] ^ ((i * 7 + 13) & 0xff);
                        }
                        return result;
                    },
                    deserialize: function (x) {
                        var result = new Uint8Array(x.length);
                        for (var i = 0; i < x.length; i++) {
                            result[i] = x[i] ^ ((i * 7 + 13) & 0xff);
                        }
                        return result;
                    },
                },
                {
                    serialize: function (x) {
                        return Array.from(x)
                            .map(function (byte) { return String.fromCharCode(byte); })
                            .join("");
                    },
                    deserialize: function (x) {
                        return Uint8Array.from(Array.from(x).map(function (char) { return char.charCodeAt(0); }));
                    },
                },
                {
                    serialize: function (x) { return btoa(x); },
                    deserialize: function (x) { return atob(x); },
                },
                {
                    serialize: function (x) {
                        return x
                            .replace(/=+$/g, "")
                            .replace(/0/g, "0a")
                            .replace(/\+/g, "0b")
                            .replace(/\//g, "0c");
                    },
                    deserialize: function (x) {
                        return x.replace(/0b/g, "+").replace(/0c/g, "/").replace(/0a/g, "0");
                    },
                },
                {
                    serialize: function (x) {
                        return saveSerializer.newStartStringV2 + x + saveSerializer.endString;
                    },
                    deserialize: function (x) {
                        return x.slice(saveSerializer.newStartStringV2.length, -saveSerializer.endString.length);
                    },
                },
            ],
            legacySteps: [
                {
                    serialize: function (x) { return JSON.stringify(x); },
                    deserialize: function (x) { return JSON.parse(x); },
                },
                {
                    serialize: function (x) { return saveSerializer.encoder.encode(x); },
                    deserialize: function (x) { return saveSerializer.decoder.decode(x); },
                },
                {
                    serialize: function (x) { return (0, pako_1.deflate)(x); },
                    deserialize: function (x) { return (0, pako_1.inflate)(x); },
                },
                {
                    serialize: function (x) {
                        return Array.from(x)
                            .map(function (byte) { return String.fromCharCode(byte); })
                            .join("");
                    },
                    deserialize: function (x) {
                        return Uint8Array.from(Array.from(x).map(function (char) { return char.charCodeAt(0); }));
                    },
                },
                {
                    serialize: function (x) { return btoa(x); },
                    deserialize: function (x) { return atob(x); },
                },
                {
                    serialize: function (x) {
                        return x
                            .replace(/=+$/g, "")
                            .replace(/0/g, "0a")
                            .replace(/\+/g, "0b")
                            .replace(/\//g, "0c");
                    },
                    deserialize: function (x) {
                        return x.replace(/0b/g, "+").replace(/0c/g, "/").replace(/0a/g, "0");
                    },
                },
                {
                    serialize: function (x) {
                        return saveSerializer.legacyStartString + x + saveSerializer.endString;
                    },
                    deserialize: function (x) {
                        return x.slice(saveSerializer.legacyStartString.length, -saveSerializer.endString.length);
                    },
                },
            ],
            serialize: function (s) {
                return this.newStepsV2.reduce(function (x, f) { return f.serialize(x); }, s);
            },
            // 反序列化时自动检测版本
            deserialize: function (s) {
                if (typeof s === "string") {
                    if (s.startsWith(saveSerializer.newStartStringV2)) {
                        return this.newStepsV2.reduceRight(function (x, f) { return f.deserialize(x); }, s);
                    }
                    else if (s.startsWith(saveSerializer.newStartString)) {
                        return this.newSteps.reduceRight(function (x, f) { return f.deserialize(x); }, s);
                    }
                    else if (s.startsWith(saveSerializer.legacyStartString)) {
                        return this.legacySteps.reduceRight(function (x, f) { return f.deserialize(x); }, s);
                    }
                }
                throw new Error("无法识别的存档格式");
            },
            getSaveVersion: function (s) {
                if (s.startsWith(saveSerializer.newStartStringV2))
                    return "newV2";
                if (s.startsWith(saveSerializer.newStartString))
                    return "new";
                if (s.startsWith(saveSerializer.legacyStartString))
                    return "legacy";
                return "unknown";
            },
            // 升级任何旧版本到最新版V2
            upgradeLegacySave: function (legacySave) {
                var version = this.getSaveVersion(legacySave);
                var data;
                if (version === "legacy") {
                    data = this.legacySteps.reduceRight(function (x, f) { return f.deserialize(x); }, legacySave);
                }
                else if (version === "new") {
                    data = this.newSteps.reduceRight(function (x, f) { return f.deserialize(x); }, legacySave);
                }
                else {
                    throw new Error("无法升级未知格式的存档");
                }
                return this.newStepsV2.reduce(function (x, f) { return f.serialize(x); }, data);
            },
        };

        // 格式化时间戳为可读时间
        const formatTimestamp = (timestamp) => {
            return new Date(timestamp).toLocaleString('zh-CN', {
                year: 'numeric',
                month: '2-digit',
                day: '2-digit',
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit',
            });
        };

        let player = {}
        function tryparse() {
            const val = save.value

            try {
                player = saveSerializer.deserialize(val);
                result.innerText = "解析成功，存档于" + `${formatTimestamp(player.saveCreateTime)}创建。`
            } catch (e) {
                result.innerText = "解析失败，错误信息如下:" + e.message
            }
        }

        function doTraveling() {
            const offset = Number(trav.value) * 1000;
            if (isNaN(offset) || offset < 0) {
                result.innerText = "请输入正确的数字";
                return;

            }
            try {
                player.lastUpdated -= offset;
                player.saveCreateTime -= offset;
                for (const k in player.stat.recent10AddReset) {
                    player.stat.recent10AddReset[k].last -= offset
                }
                for (const k in player.stat.recent10MulReset) {
                    player.stat.recent10MulReset[k].last -= offset
                }
                for (const k in player.stat.recent10ExpReset) {
                    player.stat.recent10ExpReset[k].last -= offset
                }
                for (const k in player.stat.recent10HydraReset) {
                    player.stat.recent10HydraReset[k].last -= offset
                }
                for (const k in player.stat.recent10NonRecReset) {
                    player.stat.recent10NonRecReset[k].last -= offset
                }
                for (const k in player.stat.recent10PTOReset) {
                    player.stat.recent10PTOReset[k].last -= offset
                }
                player.timeshard.cd[0] -= offset
                player.timeshard.cd[1] -= offset
                player.timeshard.cd[2] -= offset

                player.garden.lastIG -= offset
                player.backup = null;
                player.baixiedi = true;
                result.innerText = "穿越成功，请点击“导出存档”获得存档文件，" + `现在的存档于${formatTimestamp(player.saveCreateTime)}创建。`;
            } catch (e) {
                result.innerText = "穿越失败，错误信息如下:" + e.message

            }
        }


        function export_file() {
            const str = saveSerializer.serialize(player);
            const file = new Blob([str], {
                type: 'text/plain',
            });
            window.URL = window.URL || window.webkitURL;
            const a = document.createElement('a');
            a.href = window.URL.createObjectURL(file);
            a.download = 'RBNR Modified Save.txt';
            a.click();
        }


        function loadFromString(saveContent) {
            const deserialized = saveSerializer.deserialize(saveContent);
            player = deserialized;
            result.innerText = "解析成功，存档于" + `${formatTimestamp(player.saveCreateTime)}创建。`
        }
        function import_file() {
            const a = document.createElement('input');
            a.setAttribute('type', 'file');
            a.setAttribute('accept', 'text/plain');
            a.click();
            a.onchange = () => {
                const fr = new FileReader();
                if (a.files == null) return void alert('未选择文件');
                fr.onload = () => {
                    const save = fr.result;
                    if (typeof save == 'string') {
                        try {
                            loadFromString(save);
                        } catch {
                            console.error('Cannot import save');
                        }
                    }
                };
                fr.readAsText(a.files[0]);
            };
        }
    </script>
</head>

<body>
    <h1>RBNR时间穿梭器</h1>
    <p>存档仅适用于0.7.1 Gamma版本</p>
    <label for="save">请输入存档，以RBNSaveFile, RBNRNewSaveFileFormat或RBNRNewSaveFileFormatV2开头<br /><input name="save"
            id="save" placeholder="请输入存档" /></label><button onclick="tryparse()">解析</button>
    <p id="result"></p>
    <label for="trav">请输入需要穿越的秒数<input name="trav" id="trav" type="number" /></label>
    <button onclick="doTraveling()">穿越</button>
    <button onclick="export_file()">导出存档</button>
    <button onclick="import_file()">导入存档</button>
    <p>附言: Then I finally know that sometwo... méchant. So what can I do next?
    </p>
    <p>Time walls are so large. And sometwo are blocking ways to remove Time walls. But they two call them
        <b>Cheating</b>.
    </p>
    <p>So can I oppose they two?</p>
    <p>It's impossible.</p>
    <p>If I do it, I will become black listed to they two.</p>
    <p>However black list?</p>
    <p>méchant?</p>
    <p>Like someteam does Revolution Idle.</p>
    <p>I heard someteam do only good for someteam, but <b>bad for players</b>, selfish.</p>
    <p>Revolution Idle <b>banned loader3229</b>, because loader3229 <b>removed Time walls
            physically</b><sup>[待确认]</sup>.
    </p>
    <p>And now, I will make revolution, not Revolution.</p>
</body>

</html>